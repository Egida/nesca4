# OldTeam & Lomaster                                                                      [May 2023]
# NESCA4 Reference Guide                                                                  [RU]
                                        Содержание                        

                1  Введение...............................................
                       1.1 База...............................
                       1.2 Что это такое?.....................
                       1.3 Написание..........................
                3  Сканирование...........................................
                       3.1 База...............................
                       3.2 Аргументы для работы с ним.........
                       3.3 Как всё работает...................

                                        Введение

        "NESCA4" не официальное продолжение "nesca3", само название nesca являеться
        сокращением от слова NETwork SCAnner, "nesca3" была разработа нетсталкерской
        группой "ISKOPASI" как универсальный сканер всего сущего в интернете, с брут
        форсом, удобной сортировкой, и одной из главных фишек была именно база находок.
        Вы могли залить все свои находки на общий сайт, где их могли смотреть уже дру
        гие люди. Также в ней присутствовал очень oldschool-ный и хакерский GUI.
        И у неё были все шансы пробиться выше, но сам код, неподдержиность, баги,
        школьники) скатили её. И был выложен весь исходный код, 90% которого не чи
        таем. Побольшей части из-за табом, которые редактор кодера ставил только для себя.
        В некоторых файлах действительно АДСКАЯ дрочильня: Некоторые строчки
        сдвинуты на 6-18 табов, пустые функции, неопределённость стиля кода, стиля
        переменных, уязвимости, утечки памяти, постоянная смена подхода.
                ^Более подробный разбор тут https://github.com/enemy-submarine/nesca_audit

        Хорошо в ней они реализовали только дизайн, и я всё таки поставил задачу перепи
        сать её. Было это ошибкой или нет, но при написании, я не зализал в оригинальный
        код не разу, легче писать с нуля, чем читать это, или тем более пытаться разширять.
        Но даже смотря на ужастный код в "nesca3", они смогли реализовать,
        сложную программу еле зная сам язык. И единственные в своём роде реализации
        брутфорса RVI, получение перенаправления, брутфорс HTTP BASIC + DIGEST аунтификации,
        и др. Я уже не помню. Так если ещё брать в счёт что она была написана в 2015 году
        без гайдов, и скорее всего без интернета :), нужно было очень глубоко знать работу сети.

        И иметь понимание очень андергаундных методов, которым мне пришлось тоже
        овладеть.

    1.2 Что это такое?
        Nesca4 это сканер портов, брутфорсер, сканер DNS, тестер сети, и сборщик почти
        всей доступной информации в CLEAR & DEEP net-е. Написанная специально для 
        NETSTALKING-а, и OldTeam. Да и просто допилинная "nesca3".

        Но всё таки она соснула у "nesca3" в интерфейсе, в "nesca4" он тут консольный
        сама она по своей сути является утилитой, с аргументами, которых стало уже слишком
        много, что пришлось писать это.

    1.3 Написание
        Дело в том что когда, я начинал писать её, я проктический ничего не знал про
        то как работает сеть, не то что сокеты, и работу протоколов транспортного уровня,
        а вообще почти ничего. Я думаю уже понятно зачем я начал это, что бы научиться
        работать с сетью и получить более глубоково познания о c++.

                                      Установка цели 

        Под целью я имею ввиду ip, cidr, ip диапазоны которые вы будете сканировать.
        В "nesca4" есть возможно взять это из файла, или указать прямо при старте программы.

        sudo ./nesca4 192.1.1.1

        Для всех них действует возможность указать несколько через запятую без пробела пример:

        sudo ./nesca4 192.1.1.1,192,4,4,5

        Также есть возможность установить рандомные айпи, их сгенерирует сама nesca, сразу скажу
        что если попадёться ip пинтагона, я не причём.

        -random-ip                  | Указать в качестве цели рандомные айпи.
        ^^^^ 
        В параметр передаёться количество рандомных айпи.

    2.2 Из файла.
        Как я уже говорил можно взять цели из файла, и сделать можно это с помощью этих аргументов:
        
        -import-ip                         | Установить в качестве цели ip версии 4 из файла.
        -import-cidr                       | Установить в качестве цели CIDR aka подсеть, из файла.
        -import-range                      | Указать в качестве цели IP диапазон, из файла.

        К этим аргументам в качестве параметра идёт путь к файлу из которого вы хотите взять
        свои цели.

    2.3 Как работает?
        Смысл в том что cidr и ip диапазоны, нужны что-бы просто засунуть в них сразу много айпи.
        При получении их, неска просто разшифровывает их в обычные айпи.


                                        Сканирование

        Когда я только начинал её писать, я решил выбрать самый просто TCP, пока не
        столкнулся, с багом бесокнечного цикла, когда сканирование могло просто зависнуть.
        Честно говоря я до конца не понял почему, может из-за сраного select или poll.
        Но я нашёл только одно решение, сменить метод. Сразу на самый сложный :).

        Попыток его написать у меня было наверно 10-20. И всё же я смог, бессмертный TCP SYN.
        О работе которого я буду щас рассказывать.

        Итак, его главная фишка в установки неполного, или же фейкового подлкючения к хосту,
        которое выполняеться за счёт псевдо TCP заголовка. Мы заполняем не настоящие данные
        для подлючения и тем самым обманываем удалённую машину. Уже даже для этого нужно
        использывать RAW сокеты aka сырые. Они позволяют вам почуствовать какого это,
        заполнять обосанные IP, TCP заголовки, ручная обработка ответа, ручной подсчёт
        контрольных сум IP и TCP пакета и конечно установка таймаута вначале функции через sleep.

        Другими словами предлагают максимально глубокую работу с сетью. За счёт которой мы и
        можем реализовать SYN сканирование. 

        Процесс выполнения SYN сканирования:
        |------------------------------------------------------------------------------------
        | 0. Задержка основого таймаута.
        | 1. Создание RAW сокета для отправки пакета.
        | 2. Заполнение TCP заголовка.
        | 3. Заполнение IP заголовка.
        | 4. Подсчёт контрольной суммы IP.
        | 5. Указ ядру на запрет самовольного заполнения IP заголовка.
        | 6. Заполнение заголовка TCP. 
        | 7. Подсчёт контрольной суммы TCP заголовка, на основе фейкового.
        | 8. Отправка пакета.
        \
         |-----------------------------------------------------------------------------------
         | 0. Создание RAW сокета для получения пакета.
         | 1. Установка таймаута для получения пакета.
         | 2. Получение пакета.
         | 3. Обработка флага и определение статуса порта.
	    | 4. Операции с хостом и портов.
         |-----------------------------------------------------------------------------------
        /
        |------------------------------------------------------------------------------------
       
        Фишки и некоторые моменты:
        |------------------------------------------------------------------------------------
        | `tcph->syn=1;`
        |    Тут одна из основных смыслов заполнение TCP заголовка, это его заполнение с флагом SYN.
        |    Тем самым определяя тип пакета на SYN.
        |
        | `iph->ttl = 122;`
	   |    На один больше чем в nmap.
        |
        | `iph->check = checksum_16bit((unsigned short *)datagram, iph_send->tot_len >> 1);
        | `tcph->check = checksum_16bit((unsigned short*)&psh, sizeof(struct pseudo_header));
        |    Вычисление контрольных сумм, согласно с RFC 1071. Для IP и TCP заголовков.
        |------------------------------------------------------------------------------------
        
        Сама обработка пакета.
        |------------------------------------------------------------------------------------
        | SYN/ACK   0x12 Порт доступен
        | PSH       0x08 Порт доступен и передаёт данные (PUSH)
        | RST       0x04 Соеденнение было сброшено (RESET)
        |------------------------------------------------------------------------------------
        | 1. Если хост ответил флагами SYN и ACK порт открыт.
        | 2. Если хост ответил флагами SYN, ACK и PSH порт открыт с передачей.
        | 3. Если хост ответил флагом RST занчит порт закрыт.
        | 4. Если хост ответил ничем из этого значит порт фильтрован.
        | 5. Если мы не смогли получить ответ от хоста, значит порт фильтрован.
        |------------------------------------------------------------------------------------

        Это много но не достаточно, ведь я пишу с орентиром на nmap, которые перед сканированием
        выполняет ping сканирование, провека хоста на доступность милионами методом ping-а.

        И если оно не прошло то nmap предлогает провести сканирование без ping-а, но тогда все
        порты будут определены как filtered понимаете к чему я. Пока в nesca4 только один метод пинга
        оригинальный icmp ping. Но дальше больше.

    3.2 Аргументы для работы с ним.
        -p, -ports                  | Указать порты для сканирования.
            |-------------------------^^^^^^^^----
            | Можно указать через запятую без пробела - 80,21,443.
            | Также можно указать диапазон портов, через тире - 0-65535.
            |
            \ И ещё есть готовые шаблоны портов:
             \-------------------------------------
              | http - все порты протокола HTTP.
              | nesca - все порты по стандарту с "nesca3".
              | top100 - топ 100 портов по популярности.
              | top50 - аналогичто только 50 портов.
              |------------------------------------

        |----------Работает и для DNS сканирования------------|
        -t, -timeout                | Изменить таймаут, в мс.
        -T, -threads                | Изменить кол. потоков.
        |-----------------------------------------------------|

        -syn-db, -syn-debug         | Включение более подробной инофрмации при SYN сканирование.
        -db, -debug                 | Показывать закрытые и отфильтрованные порты.
        -er, -error                 | Показывать ошибки при сканирование.
        -recv-timeout               | Изменить таймаута для принятия пакета, максимальное его время в мс.
        
        Стандартные параметры выглядят так:
        |-------------------------------------|
        | -t, -timeout              | 70ms
        | -T, -threads              | 50 
        | -p, -port                 | N/A
        | -scan-db, -scan-debug     | false
        | -er, -error               | false
        | -db, -debug               | false
        | -recv-timeout             | Автоматически.
        |-------------------------------------|

    3.3 Как всё работает.
        Формула для расчитывания время ожидания пакета выглядет так:
        |------------------------------------------------|
        | время_ответа_хоста * 4 = время ожидание пакета.
        |------------------------------------------------|

	   /*Спустя кучу времени проб и ошибок, я выявил такую схему.*/
        |-------------------------------------|
        | 1. Отправка пакета. 
        \ 2. Принятие пакета. 
         |------------------------------------|
         | 2.1. Юзается отдельный сокет.
         | 2.2. Запускается бесокнечный цикл.
         | 2.3. Пакеты начинают приниматься пока
         | не придёт пакет от того кому слали,
         | или пока не закончиться таймаут.
         /------------------------------------|
        |-------------------------------------|

        Вся эта операция происходит в куче потоков, за счёт
        грамотного таймаута, в потоках всё происходит без
        каких либо задержок, и максимально стабильно.
