# OldTeam & Lomaster                                                                      [May 2023]
# NESCA4 Reference Guide                                                                  [RU]
# PS: Тут огромное количество граматических ошибок, и мне насрать. 

                                        Содержание                        

                1  Введение...............................................
                       1.1 База...............................
                       1.2 Что это такое?.....................
                       1.3 Написание..........................
                3  Сканирование...........................................
                       3.1 Сканирование портов................
                           3.1.1 SYN....................
                           3.1.2 XMAS,FIN,NULL..........
                           3.1.3 WINDOW.................
                           3.1.4 ACK....................
                           3.1.5 MAIMON.................
                       3.2 Пинг сканирование..................
                           3.2.1 TCP ACK................
                           3.2.2 TCP SYN................
                           3.2.3 ICMP методы............
                4  Обаботка...............................................
                       4.1 Определение цели.............
                       4.2 Брутфорс RVI.................
                5  Аргументы..............................................
                       5.1 Аргументы для работы со сканирование портов

                                        Введение

        "NESCA4" не официальное продолжение "nesca3", само название nesca являеться
        сокращением от слова NETwork SCAnner, "nesca3" была разработа нетсталкерской
        группой "ISKOPASI" как универсальный сканер всего сущего в интернете, с брут
        форсом, удобной сортировкой, и одной из главных фишек была именно база находок.
        Вы могли залить все свои находки на общий сайт, где их могли смотреть уже дру
        гие люди. Также в ней присутствовал очень oldschool-ный и хакерский GUI.
        И у неё были все шансы пробиться выше, но сам код, неподдержиность, баги,
        школьники) скатили её. И был выложен весь исходный код, 90% которого не чи
        таем. Побольшей части из-за табом, которые редактор кодера ставил только для себя.
        В некоторых файлах действительно АДСКАЯ дрочильня: Некоторые строчки
        сдвинуты на 6-18 табов, пустые функции, неопределённость стиля кода, стиля
        переменных, уязвимости, утечки памяти, постоянная смена подхода.
                ^Более подробный разбор тут https://github.com/enemy-submarine/nesca_audit

        Хорошо в ней они реализовали только дизайн, и я всё таки поставил задачу перепи
        сать её. Было это ошибкой или нет, но при написании, я не зализал в оригинальный
        код не разу, (Только что бы посмотреть какие порты стаят по стандарту :))
        легче писать с нуля, чем читать это, или тем более пытаться разширять.
        Но даже смотря на ужастный код в "nesca3", они смогли реализовать,
        сложную программу еле зная сам язык. И единственные в своём роде (я больше не нашёл)
        реализации брутфорса RVI, получение перенаправления, брутфорс HTTP BASIC + DIGEST
        аунтификации, и др. Я уже не помню. Так если ещё брать в счёт что она была написана
        в 2015 году без гайдов, и скорее всего без интернета :), нужно было очень глубоко
        знать работу сети.

        PS:
        Этот гайд, будет полезен как и для тех кто хочет разобраться в работе интернета,
        так и для тех кто хочет научиться нормально пользоваться nesca4, так как надо вам.

    1.2 Что это такое?
        Nesca4 это сканер портов, брутфорсер, сканер DNS, тестер сети, и сборщик почти
        всей доступной информации в CLEAR & DEEP net-е. Написанная специально для 
        NETSTALKING-а, и OldTeam. Да и просто допилинная "nesca3".

        Но всё таки она соснула у "nesca3" в интерфейсе, в "nesca4" он тут консольный
        сама она по своей сути является утилитой, с аргументами, которых стало уже слишком
        много, что пришлось писать это.

    1.3 Написание
        Дело в том что когда, я начинал писать её, я проктический ничего не знал про
        то как работает сеть, не то что сокеты, и работу протоколов транспортного уровня,
        а вообще почти ничего. Я думаю уже понятно зачем я начал это, что бы научиться
        работать с сетью и получить более глубоково познания о c++.

                                      Установка цели 

        Под целью я имею ввиду ip, cidr, ip диапазоны или dns, которые вы будете сканировать.
        В "nesca4" есть возможно взять это из файла, или указать прямо при старте программы.

        sudo ./nesca4 192.1.1.1

        Для всех них действует возможность указать несколько через запятую без пробела пример:

        sudo ./nesca4 192.1.1.1,192,4,4,5

		PS: Для указания cidr, ip диапазонов или dns, делайте точно также.

        Также есть возможность установить рандомные айпи, их сгенерирует сама nesca, сразу скажу
        что если попадёться ip пинтагона, я не причём.

        -random-ip                  | Указать в качестве цели рандомные айпи.
        ^^^^ 
        В параметр передаёться количество рандомных айпи.

    2.2 Из файла.
        Как я уже говорил можно взять цели из файла, и сделать можно это с помощью этих аргументов:
        
        -import-ip                         | Установить в качестве цели ip версии 4 из файла.
        -import-cidr                       | Установить в качестве цели CIDR aka подсеть, из файла.
        -import-range                      | Указать в качестве цели IP диапазон, из файла.

        К этим аргументам в качестве параметра идёт путь к файлу из которого вы хотите взять
        свои цели.

    2.3 Как работает?
        Смысл в том что cidr и ip диапазоны, нужны что-бы просто засунуть в них сразу много айпи.
        При получении их, неска просто разшифровывает их в обычные айпи.


                                        Сканирование
    3.1 Сканирование портов. 

        Когда я только начинал её писать, я решил выбрать самый просто TCP, пока не
        столкнулся, с багом бесокнечного цикла, когда сканирование могло просто зависнуть.
        Честно говоря я до конца не понял почему, может из-за сраного select или poll.
        Но я нашёл только одно решение, сменить метод. Сразу на самый сложный :).

        Попыток его написать у меня было наверно 10-20. 
        И всё же я смог долбануть TCP SYN. А потом пошло поехало, и добавил вообще все TCP.
        Кроме самого простого через connect. В этом нету смысла, он залагивает на каждом 2 порту.

        Как работает CAPEC-287 через которые nesca4 шлёт все TCP пакеты - 
        Итак, его главная фишка в установки неполного, или же фейкового подлкючения к хосту,
        которое выполняеться за счёт псевдо TCP заголовка, и расчёта не совсем явной контрольной суммы.
        Мы заполняем не настоящие данные для подлючения и тем самым обманываем удалённую машину.
        Уже даже для этого нужно использывать RAW сокеты aka сырые. Они позволяют вам почуствовать
        какого это, заполнять обосанные IP, TCP заголовки, ручная обработка ответа, ручной подсчёт
        контрольных сум IP и TCP пакета, и другая дрочильня.

        Процесс отправки TCP пакета с CAPEC-287:
        |------------------------------------------------------------------------------------
        | 0. Создание RAW сокета для отправки пакета.
        | 1. Заполнение TCP заголовка.
        | 2. Заполнение IP заголовка.
        | 3. Подсчёт контрольной суммы IP.
        | 4. Указ ядру на запрет самовольного заполнения IP заголовка.
        | 5. Подсчёт контрольной суммы TCP заголовка, на основе фейкового.
        | 6. Отправка пакета.
        |------------------------------------------------------------------------------------
        Теперь самый сложный и главный процесс, это приём пакета, на который я убил 2 недели. 
        Я не мог понять почему иногда пакет просто не приходит. Пока не понял что приходил но не тот.
        Дело в том что RAW сокеты принимаю вообще все пакеты которые поступают на систему.
        Поэтому я долбанул сортировочку и просто алгоритм по принятию пакета. Смотрите ниже.
        \
        | Сам код приёма тут - https://github.com/oldteamhost/nesca4/blob/main/ncsock/ncread.cc

        Процесс приёма TCP пакета через RAW сокеты:
        |------------------------------------------------------------------------------------
        | 0. Создание RAW сокета для приёма пакет.
        |       /*Создание в самой фукции по другом потоки будут гнать.*/
        | 1. Установка таймаута через poll.
        | 2. Создание структуры куда идёт IP от которого мы ждём пакет.
        |       /*Для сортировки.*/
        | 3. Запуск бесконечного цикла по приёму вообще всех пакетов которые поступают на систему. 
        |       /*Из-за raw сокета он не сортирует, мы будем сами.*/
        | 4. Принятие пакета выполняеться через recvfrom.
        |       /*Recvfrom для получения айпи отправителя.*/
        | 5. Получение IP заголовка из полученного пакета.
        |       /*Цикл также находится в работе.*/
        | 6. Получение IP отправителя из IP заголовка который мы приняли.
        | 7. Сравнение этого IP, с тем от которого мы ждём пакета.
        | 8. Также на условие сравнения IP стоит ещё один таймаут на цикл.
        |       /*Poll ставит только на принятие пакета функцию recvfrom,
        |       но не на бесокнечный цикл, там отдельные ручной таумаут.*/
        | 9. Если IP не тот и не вышел таймаут на бесокнечный цикл то он запускает его заново.
        | 10. Если тот, то возвращает буфер со всем пакетом.
        |------------------------------------------------------------------------------------

        Формула для расчитывания время ожидания пакета выглядет так:
        |------------------------------------------------|
        | время_ответа_хоста * 4 = время ожидание пакета.
        |------------------------------------------------|
        Но зависит от режима скорости аргумент -S

        Схема самого сканирования, очень лютая. WARNING мать его.
        |-------------------------------------|
        | 1. Отправка пакета. 
        | 2. Принятие пакета. 
        |------------------------------------|

        Вся эта операция происходит в куче потоков, за счёт
        грамотного таймаута, в потоках всё происходит без
        каких либо задержок, и максимально стабильно. Теперь к методам и как выполняються.

      3.1.1 SYN. 

        | Для SYN сканирования шлём такие флаги.
        |------------------------------------------------------------------------------------
        | SYN       0x02 Синхронизация номеров последовательности (SYNC)
        |------------------------------------------------------------------------------------
        |
        | Обработка пакета проходит по такому алгоритму.
        |------------------------------------------------------------------------------------
        | 1. Если хост ответил флагами SYN и ACK порт (open).
        | 2. Если хост ответил флагами SYN, ACK и PSH порт (open) с передачей.
        | 3. Если хост ответил флагом RST занчит порт (closed).
        | 4. Если хост ответил ничем из этого значит порт (filtered).
        | 5. Если мы не смогли получить ответ от хоста, значит порт (filtered).
        |------------------------------------------------------------------------------------

      3.1.2 XMAS,FIN,NULL. 

        | Для сканирования XMAS шлём такие флаги.
        |------------------------------------------------------------------------------------
        | PSH       0x08 Инструктирует получателя протолкнуть данные (PUSH)
        | FIN       0x01 Указывает на завершение соединения (FIN)
        | URG       0x20 Поле "Указатель важности" задействовано (URGENT)
        |
        | Для сканирования FIN шлём такие флаги.
        |------------------------------------------------------------------------------------
        | FIN       0x01 Указывает на завершение соединения (FIN)
        |
        | Для сканирования NULL мы не шлём флагов вообще.
        |------------------------------------------------------------------------------------
        |
        | Обработка пакета для FIN,XMAS,NULL проходит по такому алгоритму.
        |------------------------------------------------------------------------------------
        | RST       0x04 Порт закрыт, соеденение было сброшено (RESET)
        |------------------------------------------------------------------------------------
        | 1. Если хост отвелит RST значит порт (closed).
        | 2. Если что-то другое то порт (open).
        |------------------------------------------------------------------------------------

      3.1.3 WINDOW. 

        | Для сканирования WINDOW шлём такие флаги.
        |------------------------------------------------------------------------------------
        | ACK       0x10 Поле "Номер подтверждения" задействовано (ACKNOW)
        |------------------------------------------------------------------------------------
        | Тут стоит пояснить что в TCP заголовке пакета, есть такое поле как размер окна,
        | "window". И некоторые защиты от сканирования могу ставить отправлять флаги SYN & ACK,
        | хотя порт по сути закрыт. Поэтому если такой подход не работает, то мы можем определить
        | состояния порта по размеру этого окна. Ниже.
        |
        | Обработка пакета проходит по такому алгоритму.
        |------------------------------------------------------------------------------------
        | RST       0x04 Состояние пока непонятно, но соеденение было сброшено (RESET)
        |------------------------------------------------------------------------------------
        | 0. Если в ответ пришёл только флаг RST то -
        \
         | 1. Если в TCP заголовки хоста размер окна больше 0, значит порт (open).
         | 2. Если меньше значит порт (closed).
         |------------------------------------------------------------------------------------
        / 
        | 0.1. Если в ответ не пришёл флаг только флаг RST то значит порт фильтруеться.
        |------------------------------------------------------------------------------------

      3.1.4 ACK. 

        | Для сканирования ACK шлём такие флаги.
        |------------------------------------------------------------------------------------
        | ACK       0x10 Поле "Номер подтверждения" задействовано (ACKNOW)
        |------------------------------------------------------------------------------------
        | Тут тоже стоит пояснить, что это не сканирование портов, а сканирования в целях
        | определения есть ли на хосте один из типов защит.\
        |
        | Обработка пакета проходит по такому алгоритму.
        | 0. Если в ответ пришёл только флаг RST то на порте нету защит (no-filtered).
        | 1. В любом другом случае порт (filtered) и есть защита.
        |------------------------------------------------------------------------------------

      3.1.5 MAIMON. 

        | Для сканирования MAIMON шлём такие флаги.
        |------------------------------------------------------------------------------------
        | ACK       0x10 Поле "Номер подтверждения" задействовано (ACKNOW)
        | FIN       0x01 Указывает на завершение соединения (FIN)
        |------------------------------------------------------------------------------------
        | Подробнее про это сканирование тут - https://nmap.org/book/scan-methods-maimon-scan.html
        |
        | Обработка пакета проходит по такому алгоритму.
        | 0. Если в ответ пришёл только флаг RST то порт (closed).
        | 1. Если ответ не пришёл, или пришло что-то другое значит порт (open|filtered).
        |------------------------------------------------------------------------------------


    3.2 Пинг сканирование. 

        Это много но не достаточно, ведь я пишу с орентиром на nmap, которые перед сканированием
        выполняет ping сканирование, провека хоста на доступность милионами методом ping-а.

        И если оно не прошло то nmap предлогает провести сканирование без ping-а, но тогда все
        порты будут определены как filtered понимаете к чему я. Без пинга точно говорить о состояние
        порта нельзя. Такое количество методов нужно для хостов с разными защитами. Ну так вот.

        Во всех этих методов, время ответа с считаеться вот так - 

        | 0. Перед функцией принятия пакета запускается таймер.
        | 1. После того как пакет пришёл, таймер останавливаеться.
        | 2. Далее переводим это время в милисекунды, и вот наше время ответа.

      3.2.1 TCP ACK. 

        | Метод TCP ACK
        |------------------------------------------------------------------------------------
        | Выполняется также как и ACK сканирование портов, но обработка немного другая.
        | Тут прикол в том что если на хосте не стоит защиты, то он будет отвечать флагом RST.
        | И уже этого ответа нам достаточно, что бы сказать что он доступен, он сам спалился.
        |------------------------------------------------------------------------------------

      3.2.1 TCP SYN. 

        | Метод TCP SYN
        |------------------------------------------------------------------------------------
        | В отличие от nmap этот метод я сделал тоже через CAPEC-287, они не сделали этот
        | метод через него, просто потому что им нужен и пинг для запуска без ROOT прав.
        | Без RAW сокета. А мне насрать, поэтому вот так вот. Флаги такие же как и при SYN
        | сканирование портов. Но тут мы проверяем ответ, хоть каким-нибудь флагом.
        | То есть если хост в ответ послал хотя бы какой-нибудь флаг, то значит он доступен.
        |------------------------------------------------------------------------------------

      3.2.1 ICMP методы. 

        | Метод ICMP ECHO
        |------------------------------------------------------------------------------------
        | Классический метод пинга, но с недавних пор стал баниться защитами, хотя по понятиям
        | в одном из RFC написано что это не по пацански, но им насрать. Итак я не буду также
        | подробно описывать процесс как в сканирование портов, но смысл в том что мы шлём ICMP
        | пакет, с типом 8. ВНИМАНИЕ НЕ КОД 8, А ТИП. Код при всех методах должен стоять 0.
        | 
        | И так после того как мы отправили пакет типа 8, AKA Echo. То в ответ мы ждём ICMP
        | пакет типа - 0, AKA Echo Reply. Если дошёл значит хост доступен, или создатель гондон, и защита стоит.
        |------------------------------------------------------------------------------------

        | Метод ICMP INFO
        |------------------------------------------------------------------------------------
        | Тоже самое но с типом 15, и в ответ ждём 16, AKA шлём Information Request ждём
        | Information Request.
        |------------------------------------------------------------------------------------

        | Метод ICMP TIMESTAP
        |------------------------------------------------------------------------------------
        | Тоже самое но с типом 13, и в ответ ждём 14, AKA шлём Timestamp ждём Timestamp Reply.
        |------------------------------------------------------------------------------------


                                     Обработка 
    4.1 Определение цели.
        Итак, в deepweb-е очень много одинаковых страничек, у которых есть общие характерные
		параметры. Которые мы может получать что-бы установить подход к типу таких хостов,
		да и просто для желания отбросить их (negatives).

		Первый подход это - получение перенаправления, это самый эффективный метод, ведь
		таких страничек в deepweb-е самое большое количество. Nesca4 умеет получать перенаправления
		4-я методами. Это все возможные пути реализовать перенаправления на хосте.

        | Парсинг Location: из HTTP заголовка - самый распостраннёный.
        | Парсинг Content location: из HTTP заголовка - тоже часто встречается.
        | Парсинг Equiv: из кода страница - это более старый метод, но чаще всего это самое интересное.
        | Парсинг window.location.href: из кода страница - также бывают те кто делают это через JS.

		Теперь когда мы смогли получить REDIRECT, nesca4 пытается определить что находиться на странице,
		по REDIRECT. Делает она пробежав этот PATH по циклу сравнивая с базой. Если она смогла определить,
		то она проверяет поддаёться ли эта страничка HTTP брутфорсу, если да то начинает его.

		// в процессе.


                                     Аргументы 

    5.1 Аргументы для работы со сканированием.
        -p, -ports                  | Указать порты для сканирования.
            |-------------------------^^^^^^^^----
            | Можно указать через запятую без пробела - 80,21,443.
            | Также можно указать диапазон портов, через тире - 0-65535.
            |
            \ И ещё есть готовые шаблоны портов:
             \-------------------------------------
              | nesca4 - основной набор.
              | http - все порты протокола HTTP.
              | nesca - все порты по стандарту с "nesca3".
              | top100 - топ 100 портов по популярности.
              | top50 - аналогичто только 50 портов.
              |------------------------------------

        |----------Работает и для DNS сканирования------------|
        -d, -delay                  | Поставить задержку, в мс.
        -T, -threads                | Изменить кол. потоков.
        |-----------------------------------------------------|

        -max-group, -ma             | Поставить группу хостов которые nesca4 будет сканировать за раз.
                                    | Если не изменть этот параметр с добавление потоков, они будут безполезны.

        -packet-trace               | Показывать ход пакетов в nesca4, при сканирование портов.
        -db, -debug                 | Показывать закрытые и отфильтрованные порты.
        -er, -error                 | Показывать ошибки при сканирование.
        -scan-timeout               | Изменить таймаута для принятия пакета, максимальное его время в мс.
        
        Стандартные параметры выглядят так:
        |-------------------------------------|
        | -t, -timeout              | 0ms
        | -T, -threads              | 50 
        | -max-group, -ma           | 20
        | -p, -port                 | N/A
        | -er, -error               | false
        | -db, -debug               | false
        | -recv-timeout             | Автоматически формула была выше
        | -packet-trace             | false
        |-------------------------------------|
